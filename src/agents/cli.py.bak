import os
import argparse
import traceback
import asyncio
from pathlib import Path
from typing import List
from dotenv import load_dotenv

from .agent import create_react_agent
from .codact_agent import create_codact_agent

try:
    from rich.console import Console
    from rich.markdown import Markdown
    from rich.panel import Panel
    from rich.live import Live
    from rich.status import Status
    from prompt_toolkit import PromptSession
    from prompt_toolkit.history import FileHistory

except ImportError as e:
    error_message = (
        f"Error: Required CLI dependencies are missing ({e}).\n"
        "Please install them using:\n"
        'uv pip install "DeepSearch-AgentTeam[cli]"\n'
    )
    print(error_message)
    exit(1)

load_dotenv()


# --- CLI Helper Functions ---

def display_welcome(args, console: Console):
    """
    Display welcome information
    """
    readme_path = 'README.md'
    description = ""
    try:
        with open(readme_path, "r") as f:
            readme_content = f.read()
        # 更健壮地查找描述部分
        description_match = readme_content.split("## 1. Introduction")
        if len(description_match) > 1:
            description_content = description_match[1].split("##")[0].strip()
            description = description_content if description_content else ""
        else:
            description_section = readme_content.split("## Description")
            if len(description_section) > 1:
                description_content = description_section[1].split("##")[0].strip()
                description = description_content if description_content else ""

    except FileNotFoundError:
        console.print(
            f"[yellow]警告:[/yellow] 未在预期位置找到 README.md: {readme_path}"
        )
    except Exception as e:
        console.print(f"[yellow]警告:[/yellow] 无法读取或解析 README.md: {e}")

    console.print(Panel(
        Markdown(description) if description else
        "DeepSearchAgent (ReAct-CodeAct 深度搜索智能体) "
        "是一个能够进行迭代式网页深度搜索和深度研究的 AI 智能体团队。",
        title="[bold cyan]DeepSearchAgent React 🚀[/bold cyan]",
        border_style="cyan",
    ))

    config_text = (
        f"代理类型: [bold cyan]{args.agent_type.upper()}[/bold cyan]\n"
        f"搜索模型: [cyan]{args.model_name}[/cyan]\n"
        f"协调模型: [cyan]{args.orchestrator_model}[/cyan]\n"
        f"重排序器: [cyan]{args.reranker}[/cyan]\n"
        f"搜索结果数量: [cyan]{args.max_sources}[/cyan]\n"
        f"详细模式 (工具日志): [cyan]{'开启' if args.verbose else '关闭'}[/cyan]"
    )

    # 根据agent_type显示特定的模式信息
    if args.agent_type == "codact":
        config_text += f"\n执行器类型: [cyan]{args.executor_type}[/cyan]\n" + \
                      f"最大步骤数: [cyan]{args.max_steps}[/cyan]"

    console.print(Panel(
        config_text,
        title="[bold blue]配置信息[/bold blue]",
        border_style="blue",
    ))

    console.print("\n[dim]提示：输入 /exit 或 /quit 退出。输入 /multiline 切换。[/dim]")
    console.print("[bold]示例查询：[/bold]")
    console.print(
        "  • 搜索 Google OpenAI 和 Anthropic 最新一周发布的所有新产品," +
        "LLM模型,技术,论文,搜索&分析后总结给我。"
    )
    console.print("  • 搜索并总结过去一周关于语言模型 (LLM) 的重要科技新闻。")


def handle_slash_command(
    command: str,
    multiline: bool,
    console: Console
) -> tuple[int | None, bool]:
    """处理斜杠命令"""
    if command in ('/exit', '/quit'):
        console.print("[dim]正在退出...[/dim]")
        return 0, multiline
    elif command == '/multiline':
        multiline = not multiline
        if multiline:
            console.print(
                '[cyan]已启用多行模式。[/cyan] [dim]按 Esc+Enter 或 '
                'Ctrl+D (Unix) / Ctrl+Z+Enter (Win) 提交。[/dim]'
            )
        else:
            console.print('[cyan]已禁用多行模式。[/cyan]')
        return None, multiline
    # Add other commands like /markdown if needed
    # elif command == '/markdown':
    #     # ... (implementation to show last response markdown)
    #     pass
    else:
        console.print(f'[red]未知命令:[/red] {command}')
        return None, multiline


async def process_query_async(
    query: str,
    agent_instance,
    verbose_mode: bool,
    console: Console,
    last_response_md: List[str]  # Use list to pass by reference
):
    """
    异步处理查询并显示结果
    """
    status = Status("[cyan]Thinking...[/cyan]", console=console)
    live_params = {
        "console": console,
        "refresh_per_second": 10,
        "vertical_overflow": "visible"
    }
    live = Live(status, **live_params)
    last_response_md.clear()  # Clear previous response

    try:
        with live:
            # Use run_in_executor for the blocking agent.run call
            loop = asyncio.get_running_loop()
            result_str = await loop.run_in_executor(
                None, agent_instance.run, query
            )

        last_response_md.append(result_str)

        console.print("\n[bold green]回答:[/bold green]")
        console.print(Panel(
            Markdown(result_str),
            title="最终回答",
            border_style="green"
        ))

    except Exception:
        # Ensure live display stops before printing error
        live.stop()
        console.print(f"[bold red]处理查询 ' {query[:50]}...' 时出错:[/bold red]")
        console.print(traceback.format_exc())  # More detailed traceback
    finally:
        if live.is_started:
            live.stop()


async def run_interactive_cli(
    agent_instance,
    args: argparse.Namespace,
    console: Console
):
    """
    运行交互式 CLI 循环
    """
    history_path = Path.home() / ".deepsearch-agent-history.txt"
    session = PromptSession(history=FileHistory(str(history_path)))
    multiline = False
    last_response_md: List[str] = []  # To store the last response

    while True:
        try:
            # auto_suggest = AutoSuggestFromHistory() # Add suggestions
            prompt_text = "DeepSearchAgent ➤ "
            text = await session.prompt_async(prompt_text, multiline=multiline)

        except (KeyboardInterrupt, EOFError):
            console.print("[dim]收到退出。[/dim]")
            break

        if not text.strip():
            continue

        command = text.strip()
        if command.startswith('/'):
            exit_code, multiline = handle_slash_command(
                command, multiline, console
            )
            if exit_code is not None:
                break  # Exit loop if exit code is returned
        else:
            await process_query_async(
                text, agent_instance, args.verbose, console, last_response_md
            )
    return 0  # Indicate normal exit


def select_agent_type(console: Console) -> str:
    """交互式选择代理类型"""
    console.print(Panel(
        "请选择要使用的代理类型:\n\n" +
        "[1] [cyan]React[/cyan] - 标准代理 (JSON工具调用模式)\n" +
        "    适合简单查询，每次工具调用后会思考下一步操作\n\n" +
        "[2] [cyan]CodeAct[/cyan] - 深度搜索代理 (Python代码执行模式)\n" +
        "    适合复杂查询，可以编写Python代码实现更灵活的搜索策略",
        title="[bold blue]代理类型选择[/bold blue]",
        border_style="blue",
    ))

    while True:
        choice = input("请输入选项编号 [1/2]: ").strip()
        if choice == "1":
            return "react"
        elif choice == "2":
            return "codact"
        else:
            console.print("[red]无效选择，请输入1或2[/red]")


# --- 主接口 --- #

def main():
    """
    CLI 主入口点
    """
    console = Console()

    parser = argparse.ArgumentParser(
        description=(
            '运行 DeepSearch-AgentTeam ReAct-CodeAct 深度搜索智能体 '
            '(迭代搜索模式) CLI'
        )
    )
    parser.add_argument(
        '--orchestrator-model',
        default=os.getenv(
            "LITELLM_ORCHESTRATOR_MODEL_ID",
            "openai/openrouter/openai/o4-mini-high"
        ),
        help='编排使用的语言模型名称 (例如 LiteLLM 兼容 ID)'
    )
    parser.add_argument(
        '--model-name',
        default=os.getenv(
            "LITELLM_SEARCH_MODEL_ID",
            "openai/openrouter/openai/o4-mini-high"
        ),
        help='搜索模型名称 (主要由 Agent 内部工具决定，此处可能仅用于显示)'
    )
    parser.add_argument(
        '--reranker',
        default=os.getenv(
            "RERANKER_TYPE", "jina-reranker-m0"
        ),
        help="重排序器类型 (例如 'jina-reranker-m0')"
    )
    parser.add_argument(
        '--max-sources',
        type=int,
        default=int(os.getenv("MAX_SOURCES", 5)),
        help='搜索结果数量 (影响 SearchLinksTool)'
    )
    parser.add_argument(
        '--pro-mode',
        action='store_true',
        default=os.getenv("PRO_MODE", "False").lower() == 'true',
        help='是否启用专业模式 (当前未直接使用，但保留接口)'
    )
    parser.add_argument(
        '--verbose',
        action='store_true',
        default=os.getenv("VERBOSE_TOOL_CALLBACKS", "True").lower() == 'true',
        help='显示详细的处理过程 (包括工具调用日志)'
    )
    parser.add_argument(
        '--query',
        type=str,
        help='直接运行单个查询, 而不启动交互式CLI'
    )
    parser.add_argument(
        '--agent-type',
        choices=['react', 'codact'],
        default='react',
        help='选择使用的代理类型: react (JSON工具调用) 或 codact (Python代码执行)'
    )
    parser.add_argument(
        '--executor-type',
        choices=['local', 'docker', 'e2b'],
        default='local',
        help='CodeAct代理的代码执行器类型'
    )
    parser.add_argument(
        '--max-steps',
        type=int,
        default=30,
        help='代理执行的最大步骤数（CodeAct推荐更高值）'
    )
    parser.add_argument(
        '--no-interactive',
        action='store_true',
        help='禁用交互式选择代理类型，直接使用--agent-type参数'
    )

    args = parser.parse_args()

    # 如果没有使用--no-interactive参数，并且没有指定单个查询，则提供交互式选择
    if not args.no_interactive and not args.query:
        # 如果命令行没有明确指定代理类型，则进行交互式选择
        if args.agent_type == parser.get_default('agent_type'):
            args.agent_type = select_agent_type(console)
            # 更新显示，让用户知道选择已生效
            console.print(
                f"[green]已选择[/green]: "
                f"[cyan]{args.agent_type.upper()}[/cyan] 代理模式"
            )

    # --- 创建代理 --- #
    try:
        # Pass cli_console only if verbose is enabled
        cli_console_for_agent = console if args.verbose else None

        if args.agent_type == 'react':
            agent_instance = create_react_agent(
                orchestrator_model_id=args.orchestrator_model,
                search_model_name=args.model_name,
                reranker_type=args.reranker,
                verbose_tool_callbacks=args.verbose,
                cli_console=cli_console_for_agent,
            )
            if agent_instance is None:
                console.print(
                    "[bold red]错误:[/bold red] "
                    "无法初始化 React Agent，可能缺少必要的 API 密钥。"
                )
                exit(1)
        else:  # codact
            agent_instance = create_codact_agent(
                orchestrator_model_id=args.orchestrator_model,
                search_model_name=args.model_name,
                reranker_type=args.reranker,
                verbose_tool_callbacks=args.verbose,
                cli_console=cli_console_for_agent,
                executor_type=args.executor_type,
                max_steps=args.max_steps,
                # 调整日志级别: verbose -> INFO(1), not verbose -> WARNING(2)
                verbosity_level=1 if args.verbose else 2
            )
            if agent_instance is None:
                console.print(
                    "[bold red]错误:[/bold red] "
                    "无法初始化 CodeAct Agent，可能缺少必要的 API 密钥。"
                )
                exit(1)

    except ValueError as e:
        console.print(f"[bold red]初始化 Agent 时出错:[/bold red] {e}")
        exit(1)
    except Exception:
        console.print("[bold red]创建 Agent 时发生未知错误:[/bold red]")
        console.print(traceback.format_exc())
        exit(1)

    display_welcome(args, console)

    # --- 运行模式 --- #
    if args.query:
        console.print(f"[yellow]运行单个查询:[/yellow] {args.query}")
        # Need a way to store the last response for single query mode
        last_response_md_single: List[str] = []
        # Run the single query processing within an event loop
        try:
            # 使用 asyncio.run() 来管理事件循环
            asyncio.run(process_query_async(
                args.query, agent_instance, args.verbose,
                console, last_response_md_single
            ))
            exit_code = 0
        except KeyboardInterrupt:
            console.print("[dim]收到中断信号。[/dim]")
            exit_code = 1
        except Exception:
            console.print("[bold red]执行单个查询时发生意外错误。[/bold red]")
            exit_code = 1
        exit(exit_code)

    else:
        # Start interactive loop
        try:
            # 使用 asyncio.run() 来管理事件循环
            exit_code = asyncio.run(
                run_interactive_cli(agent_instance, args, console)
            )
            exit(exit_code)
        except KeyboardInterrupt:
            console.print("[dim]交互式会话中断。[/dim]")
            exit(1)
        except Exception:
            console.print("[bold red]运行交互式 CLI 时发生意外错误。[/bold red]")
            console.print(traceback.format_exc())
            exit(1)


if __name__ == "__main__":
    main()
