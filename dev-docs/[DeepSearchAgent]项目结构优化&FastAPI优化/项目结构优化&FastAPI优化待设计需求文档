# [DeepSearchAgent]项目结构优化&FastAPI优化待设计需求文档

DeepSearchAgents 当前项目结构优化分析
DeepSearchAgents 项目当前面临的结构优化问题主要包括：

1. FastAPI应用集中在`main.py`中，需要进行模块化解耦
2. 代理命名不一致(`agent.py`和`codact_agent.py`)
3. 整体项目结构不够清晰，不符合FastAPI最佳实践
4. 运行时配置加载逻辑分散，需要统一

## 优化分析

### 1. 项目结构重组

```
src/
├── main.py                # 精简的 FastAPI [DeepSearchAgent]应用入口
├── api/                   # API路由
│   ├── __init__.py
│   ├── v1/
│   │   ├── __init__.py
│   │   ├── router.py      # 路由聚合
│   │   ├── endpoints/     # 各个API端点
│   │   │   ├── __init__.py
│   │   │   ├── agent.py   # 代理相关端点
│   │   │   └── health.py  # 健康检查端点
│   │   └── router.py      # v1版本路由汇总
│   └── api.py             # API应用定义
├── agents/                # 代理实现
│   ├── __init__.py
│   └── runtime.py         # 统一代理运行时
│   ├── base_agent.py      # 代理基类（可选,react & codact 的公共基类）
│   ├── react_agent.py     # 当前agent.py重命名
│   ├── codact_agent.py    # 代码执行代理
│   └── prompt_templates/  # 提示模板保持不变
│       ├── __init__.py
│       ├── codact_prompts.py
│       └── react_prompts.py
├── core/                  # 核心功能
│   ├── __init__.py
│   ├── config/
│   │   ├── __init__.py
│   │   └── settings.py    # 使用pydantic模型管理配置（当前config_loader.py）
│   ├── chunk/             # 保持现有结构
│   ├── ranking/           # 保持现有结构
│   ├── scraping/          # 保持现有结构
│   └── search_engines/    # 保持现有结构
├── tools/                 # 工具保持现有结构
│   ├── __init__.py
│   └── ...
└── cli.py                 # TUI Dev 调试台交互终端命令行界面
```

### 2. FastAPI解耦优化

将`main.py`拆分为：

1. `main.py` - 精简的入口点
2. `api/api.py` - FastAPI应用定义
3. `api/v1/endpoints/*.py` - 不同功能的API端点

例如：

```python
# src/main.py
import os
import uvicorn
from api.api import create_app
from core.config.settings import settings

app = create_app()

if __name__ == "__main__":
    log_level = os.getenv("LOG_LEVEL", "info").lower()
    
    print(f"启动FastAPI服务器: http://{settings.SERVICE_HOST}:{settings.SERVICE_PORT}")
    
    uvicorn.run(
        "main:app",
        host=settings.SERVICE_HOST,
        port=settings.SERVICE_PORT,
        log_level=log_level
    )

```

例如：

```python
# src/api/api.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from api.v1.router import api_router
from core.config.settings import settings

def create_app() -> FastAPI:
    """创建并配置FastAPI应用"""
    app = FastAPI(
        title="DeepSearch Agents API",
        description="提供Search Agent API，支持React模式或CodeAct-ReAct Agent深度搜索模式",
        version=settings.VERSION,
    )
    
    # CORS中间件
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # 注册路由
    app.include_router(api_router)
    
    @app.on_event("startup")
    async def startup_event():
        """应用启动事件处理"""
        print("\n--- 已注册路由 ---")
        for route in app.routes:
            if hasattr(route, "path"):
                methods_str = str(getattr(route, 'methods', 'N/A'))
                print(f"路径: {route.path}, 方法: {methods_str}")
        print("--- 路由列表结束 ---\n")
    
    return app

```

### 3. 配置加载与配置管理优化

将`config_loader.py`重构为`core/config/settings.py`：

例如：

```python
# src/core/config/settings.py
from pydantic import BaseSettings, Field
from typing import Dict, Any, List, Optional
import yaml
import os

class Settings(BaseSettings):
    # 服务配置
    SERVICE_HOST: str = "0.0.0.0"
    SERVICE_PORT: int = 8000
    VERSION: str = "0.2.4.dev"
    DEEPSEARCH_AGENT_MODE: str = "codact"
    
    # 模型配置
    ORCHESTRATOR_MODEL_ID: str = "openrouter/openai/o4-mini-high"
    SEARCH_MODEL_NAME: str = "openrouter/openai/o4-mini-high"
    RERANKER_TYPE: str = "jina-reranker-m0"
    
    # React代理配置
    REACT_MAX_STEPS: int = 25
    REACT_ENABLE_STREAMING: bool = False
    REACT_PLANNING_INTERVAL: int = 7
    
    # CodeAct代理配置
    CODACT_EXECUTOR_TYPE: str = "local"
    CODACT_MAX_STEPS: int = 25
    CODACT_VERBOSITY_LEVEL: int = 1
    CODACT_ENABLE_STREAMING: bool = False
    CODACT_PLANNING_INTERVAL: int = 4
    CODACT_EXECUTOR_KWARGS: Dict[str, Any] = Field(default_factory=dict)
    CODACT_ADDITIONAL_IMPORTS: List[str] = Field(default_factory=list)
    
    # 通用配置
    VERBOSE_TOOL_CALLBACKS: bool = True
    
    class Config:
        env_file = ".env"
        
    def get_api_key(self, key_name: str) -> Optional[str]:
        """获取API密钥"""
        return os.getenv(key_name)

# 加载YAML配置并覆盖默认值
def load_yaml_config(settings_instance: Settings):
    config_path = os.getenv("CONFIG_PATH", "config.yaml")
    if os.path.exists(config_path):
        with open(config_path, "r") as f:
            yaml_config = yaml.safe_load(f)
        
        # 递归更新配置
        _update_settings(settings_instance, yaml_config)
    return settings_instance

def _update_settings(settings_instance: Settings, config: Dict[str, Any], prefix: str = ""):
    """递归更新设置值"""
    for key, value in config.items():
        if isinstance(value, dict):
            _update_settings(settings_instance, value, f"{prefix}{key}_")
        else:
            setting_key = f"{prefix}{key}".upper()
            if hasattr(settings_instance, setting_key):
                setattr(settings_instance, setting_key, value)

# 创建单例settings实例
settings = load_yaml_config(Settings())

```

### 4. 代理运行时统一

创建`agent_run.py`提供统一的代理运行接口：

例如：

```python
# src/agents/runtime.py
import asyncio
import time
import traceback
from typing import Optional, Literal
from core.config.settings import settings
from agents.react_agent import create_react_agent
from agents.codact_agent import create_codact_agent

class AgentRuntime:
    """DeepSearchAgent统一运行时"""
    
    def __init__(self, agent_type: Literal["react", "codact"] = None):
        """初始化代理运行时"""
        self.agent_type = agent_type or settings.DEEPSEARCH_AGENT_MODE
        self.react_agent = None
        self.code_agent = None
        
        # 获取API密钥
        self.litellm_master_key = settings.get_api_key("LITELLM_MASTER_KEY")
        self.serper_api_key = settings.get_api_key("SERPER_API_KEY")
        self.jina_api_key = settings.get_api_key("JINA_API_KEY")
        self.wolfram_app_id = settings.get_api_key("WOLFRAM_ALPHA_APP_ID")
        self.litellm_base_url = settings.get_api_key("LITELLM_BASE_URL")
        
        # 初始化代理
        self._initialize_agents()
        
    def _initialize_agents(self):
        """初始化代理实例"""
        try:
            # 初始化React代理
            self.react_agent = create_react_agent(
                orchestrator_model_id=settings.ORCHESTRATOR_MODEL_ID,
                search_model_name=settings.SEARCH_MODEL_NAME,
                reranker_type=settings.RERANKER_TYPE,
                verbose_tool_callbacks=settings.VERBOSE_TOOL_CALLBACKS,
                litellm_master_key=self.litellm_master_key,
                litellm_base_url=self.litellm_base_url,
                serper_api_key=self.serper_api_key,
                jina_api_key=self.jina_api_key,
                wolfram_app_id=self.wolfram_app_id,
                cli_console=None,
                enable_streaming=settings.REACT_ENABLE_STREAMING
            )
            
            # 初始化CodeAct代理
            self.code_agent = create_codact_agent(
                orchestrator_model_id=settings.ORCHESTRATOR_MODEL_ID,
                search_model_name=settings.SEARCH_MODEL_NAME,
                reranker_type=settings.RERANKER_TYPE,
                verbose_tool_callbacks=settings.VERBOSE_TOOL_CALLBACKS,
                executor_type=settings.CODACT_EXECUTOR_TYPE,
                max_steps=settings.CODACT_MAX_STEPS,
                verbosity_level=settings.CODACT_VERBOSITY_LEVEL,
                executor_kwargs=settings.CODACT_EXECUTOR_KWARGS,
                additional_authorized_imports=settings.CODACT_ADDITIONAL_IMPORTS,
                litellm_master_key=self.litellm_master_key,
                litellm_base_url=self.litellm_base_url,
                serper_api_key=self.serper_api_key,
                jina_api_key=self.jina_api_key,
                wolfram_app_id=self.wolfram_app_id,
                cli_console=None,
                enable_streaming=settings.CODACT_ENABLE_STREAMING
            )
        except Exception as e:
            print(f"[错误] 代理初始化失败: {e}")
            traceback.print_exc()
            
    async def run(self, user_input: str, agent_type: Optional[str] = None) -> str:
        """运行代理处理用户输入"""
        agent_type = agent_type or self.agent_type
        
        if agent_type == "react":
            if self.react_agent is None:
                return "错误: React代理初始化失败"
            agent = self.react_agent
        elif agent_type == "codact":
            if self.code_agent is None:
                return "错误: CodeAct代理初始化失败"
            agent = self.code_agent
        else:
            return f"错误: 未知的代理类型 '{agent_type}'"
            
        try:
            loop = asyncio.get_running_loop()
            start_time = time.time()
            result = await loop.run_in_executor(None, agent.run, user_input)
            execution_time = time.time() - start_time
            print(f"代理执行完成，耗时 {execution_time:.2f} 秒")
            return result
        except Exception as e:
            error_message = f"处理请求时出错: {str(e)}"
            print(f"执行代理时出错: {e}")
            traceback.print_exc()
            return error_message

# 全局代理运行时实例
agent_runtime = AgentRuntime()

```

### 5. API端点重构

将API端点拆分到`api/v1/endpoints/`目录：

例如：

```python
# src/api/v1/endpoints/agent.py
from fastapi import APIRouter, HTTPException
from fastapi.responses import PlainTextResponse
from pydantic import BaseModel, Field
from typing import Optional, Dict, Any
from agents.runtime import agent_runtime

router = APIRouter()

class UserInput(BaseModel):
    user_input: str = Field(..., description="用户查询内容")

class DeepSearchRequest(BaseModel):
    user_input: str = Field(..., description="用户查询内容")
    agent_type: Optional[str] = Field("codact", description="使用的代理类型 (codact 或 react)")
    model_args: Optional[Dict[str, Any]] = Field(None, description="模型额外参数")

@router.post("/run_react_agent", response_class=PlainTextResponse)
async def run_agent_endpoint(input_data: UserInput) -> PlainTextResponse:
    """执行React代理"""
    result = await agent_runtime.run(input_data.user_input, "react")
    
    if result.startswith("错误:") or result.startswith("处理请求时出错:"):
        return PlainTextResponse(content=result, status_code=500)
    else:
        return PlainTextResponse(content=result)

@router.post(
    "/run_deepsearch_agent",
    response_class=PlainTextResponse,
    operation_id="deep_search",
    tags=["agents"],
    summary="执行深度网络搜索和分析",
    description="对给定查询执行全面的网络搜索和分析，返回详细结果"
)
async def run_deepsearch_agent(input_data: UserInput) -> PlainTextResponse:
    """运行DeepSearch代理"""
    result = await agent_runtime.run(input_data.user_input)
    
    if result.startswith("错误:") or result.startswith("处理请求时出错:"):
        return PlainTextResponse(content=result, status_code=500)
    else:
        return PlainTextResponse(content=result)

```

例如：

```python
# src/api/v1/endpoints/health.py
from fastapi import APIRouter
from core.config.settings import settings
from agents.runtime import agent_runtime

router = APIRouter()

@router.get("/")
async def read_root():
    """健康检查端点"""
    react_status = "ok" if agent_runtime.react_agent else "error"
    code_status = "ok" if agent_runtime.code_agent else "error"
    
    agents_info = {
        "react_agent": {
            "status": react_status,
            "endpoint": "/run_react_agent",
            "model": settings.ORCHESTRATOR_MODEL_ID if react_status == "ok" else None
        },
        "deepsearch_agent": {
            "status": code_status,
            "endpoint": "/run_deepsearch_agent",
            "model": settings.ORCHESTRATOR_MODEL_ID if code_status == "ok" else None,
            "executor_type": settings.CODACT_EXECUTOR_TYPE,
            "max_steps": settings.CODACT_MAX_STEPS
        }
    }
    
    return {
        "message": "DeepSearch-AgentTeam API服务正在运行",
        "agents": agents_info,
        "version": settings.VERSION
    }

```

例如：

```python
# src/api/v1/router.py
from fastapi import APIRouter
from api.v1.endpoints import agent, health

api_router = APIRouter()

# 包含各端点路由
api_router.include_router(health.router, tags=["health"])
api_router.include_router(agent.router, prefix="/agents", tags=["agents"])

```

### 6. 重命名`agent.py`为`react_agent.py`

现有的`agent.py`应重命名为`react_agent.py`，同时更新所有引用。

## 实施步骤

1. 创建 "0.2.5.dev" tag&dev分支
2. 创建新的目录结构: 按照上述结构创建目录和文件
3. 配置管理重构: 将 `config_loader.py` 转换为基于Pydantic的 `settings.py`
4. 实现统一运行时: 创建 `agents/runtime.py` 统一代理运行逻辑
5. API解耦: 拆分 `main.py` 为多个独立模块
6. 重命名 `agent.py` : 将 `agent.py` 重命名为 `react_agent.py` 保持API兼容
7. 更新导入路径: 更新所有模块中的导入路径

## "0.2.5.dev" 目标

- 确保项目结构优化时, 不影响原有Agents功能
- 提高可维护性: 模块化结构使代码更易于理解和维护
- 增强可扩展性: 清晰的结构便于添加新功能和API版本
- 代码重用: 减少重复代码，提高复用性
- 配置集中管理: 使用Pydantic模型统一管理配置
- 符合最佳实践: 遵循FastAPI项目组织的最佳实践

这种优化结构将使[DeepSearchAgent]项目更加模块化,可维护, 并为未来的扩展提供更好的基础架构。
